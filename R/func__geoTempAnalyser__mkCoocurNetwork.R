#' @title Converting a given network into a co-occurrence network
#'
#' @param net A Graph object defining a network whose edge attributes must include
#' "d_min" and "d_max" for the ingroup distances when the parameter d is specified.
#' The first two columns of the edge attribute must be node names.
#' @param pam An allelic presence-absence matrix produced by the function
#' importAllelicPAM.
#' @param sam A data frame of sample information. It must have two columns named
#' "Year_low" and "Year_up" for the lower bound and upper bound of years that an
#' isolate was obtained. For isolates whose isolation years are known explicitly,
#' Year_low = Year_up. In addition, the first column must be isolate names.
#' @param years An integer vector for every year the co-occurrence network is
#' generated. Leave this argument as 0 (default) to disable year-based sampling.
#' @param ds A data frame of allelic physical distances, which is generated by the
#' physDist pipeline.
#'
#' @return A list of a GraphSet object G, a named numeric vector w for weighted
#' occurrence count per isolate, when years > 0; a list of a Graph object G and
#' the same vector w when years <= 0.
#'
#' @export
#  Copyright 2018 Yu Wan
#  Licensed under the Apache License, Version 2.0
#  First edition: 11 Aug 2018, the latest edition: 11 Aug 2018

mkCoocurNetwork <- function(net, pam = NULL, sam = NULL, years = 0, ds = NULL) {
    # Unify column name
    if (names(sam)[1] != "Strain") {
        names(sam)[1] <- "Strain"
    }

    # Calculate weighted occurrence counts. For instance, if an isolate was obtained
    # between 2017 and 2018, then its weighted occurence count of an allele is
    # 0.5 for each year.
    year_range <- sam$Year_up - sam$Year_low + 1
    ws <- round(1 / year_range, digits = 4)  # weight for allelic presence per year: the wider the range, the smaller the weight
    names(ws) <- sam$Strain  # the weights
    ws <- ws[rownames(pam)]  # match the weights with strain names in the PAM
    #W <- diag(as.numeric(w_counts))  # construct a square diagonal matrix
    #rownames(W) <- rownames(pam)  # Otherwise, PAM loses row names in the next step.
    #pam <- W %*% pam  # Convert the allelic PAM into a weighted PAM by multiplying the weights to rows of PAM, which is essentially weight the allelic presence-absence for each strain

    # Convert the network into an undirected network
    no_pair <- !any(names(net@E) == "pair")
    if (no_pair) {
        net@E <- assignPairID(lmms = net@E, paired.rows = FALSE)  # a "pair" column will be appended to this data frame
    }
    E <- net@E[!duplicated(net@E$pair), ]
    if (no_pair) {
        E <- E[, -ncol(E)]  # drop the last column - "pair"
    }
    names(E)[c(1, 2)] <- c("a1", "a2")  # allele 1 and 2

    # Get co-occurrence count for each pair of alleles in each year


    if (years[1] > 0) {  # temporal mode
        co <- vector(mode = "list", length = 0)
        for (yr in years) {
            strains_yr <- sam$Strain[(sam$Year_low <= yr) & (sam$Year_up >= yr)]  # strains of that year
            n <- length(strains_yr)  # sample size of that year
            if (n > 1) {  # multiple strains
                pam_yr <- pam[strains_yr, ]
                ds_yr <- subset(ds, sample %in% strains_yr)
                ws_yr <- ws[strains_yr]
                co[[as.character(yr)]] <- .countCoocurrencePerYear(E, pam_yr, ds_yr, ws_yr)
            } else if (n == 1) {  # Only a single strain was obtained in that year.
                pam_yr <- pam[strains_yr, ]  # a named vector
                ds_yr <- subset(ds, sample == strains_yr)
                ws_yr <- ws[[strains_yr]]  # a numeric value
                co[[as.character(yr)]] <- .countCoocurrencePerYear(E, pam_yr, ds_yr, ws_yr)
            } else {
                print(paste0("No strain was isolated in the year ", yr, "."))
                co[[as.character(yr)]] <- NULL
            }
        }
        out <- list(G = new("GraphSet", V = net@V, E = co), w = ws)
    } else {  # overview mode
        co <- .countCoocurrencePerYear(E = E, pam_yr = pam, ds_yr = ds, ws_yr = ws)
        out <- list(G = new("Graph", V = net@V, E = co, id = "all"), w = ws)
    }

    return(out)
}

.countCoocurrencePerYear <- function(E, pam_yr, ds_yr, ws_yr) {
    # a subordinate function of mkCoocurNetwork
    e_yr <- data.frame(a1 = character(0), a2 = character(0), n_co = integer(0),
                       n_co_w = numeric(0), n_d = integer(0),
                       m = numeric(0), stringsAsFactors = FALSE)

    for (i in 1 : nrow(E)) {  # go through every edge
        e <- E[i, ]  # take an edge from the undirected network
        a1 <- e$a1
        a2 <- e$a2

        if (is.matrix(pam_yr)) {
            v_co <- pam_yr[, a1] * pam_yr[, a2]  # a binary vector of co-occurrence status
        } else {
            v_co <- pam_yr[[a1]] * pam_yr[[a2]]  # a binary variable
        }

        n_co <- sum(v_co)
        n_co_w <- sum(v_co * ws_yr)  # weighted co-occurrence count
        if (n_co > 0) {
            if (nrow(ds_yr) > 0) {
                ds_yr_a12 <- getRowsXY(df = ds_yr, k1 = a1, k2 = a2, c1 = "query1", c2 = "query2")
                if (nrow(ds_yr_a12) > 0) {
                    d <- ds_yr_a12$distance
                    n_d_a12 <- sum(d >= e$d_min & d <= e$d_max)  # in-group distances
                    e_yr <- rbind.data.frame(e_yr,
                                             data.frame(a1 = a1, a2 = a2, n_co = n_co,
                                                        n_co_w = n_co_w, n_d = n_d_a12,
                                                        m = round(n_d_a12 / n_co, digits = 4),
                                                        stringsAsFactors = FALSE),
                                             stringsAsFactors = FALSE)
                } else {  # No distance available for the current pair of alleles this year
                    e_yr <- rbind.data.frame(e_yr,
                                             data.frame(a1 = a1, a2 = a2, n_co = n_co,
                                                        n_co_w = n_co_w, n_d = 0, m = 0,
                                                        stringsAsFactors = FALSE),
                                             stringsAsFactors = FALSE)
                }
            } else {  # No distance is available for that year.
                e_yr <- rbind.data.frame(e_yr,
                                         data.frame(a1 = a1, a2 = a2, n_co = n_co,
                                                    n_co_w = n_co_w, n_d = 0, m = 0,
                                                    stringsAsFactors = FALSE),
                                         stringsAsFactors = FALSE)
            }
        } else {
            e_yr <- rbind.data.frame(e_yr,
                                     data.frame(a1 = a1, a2 = a2, n_co = 0,
                                                n_co_w = 0, n_d = 0, m = 0,
                                                stringsAsFactors = FALSE),
                                     stringsAsFactors = FALSE)
        }
    }

    # Attach other columns
    e_yr <- merge(x = e_yr, y = E, by = c("a1", "a2"), all.x = TRUE, all.y = FALSE, sort = FALSE)

    return(e_yr)
}
